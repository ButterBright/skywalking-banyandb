// Licensed to Apache Software Foundation (ASF) under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Apache Software Foundation (ASF) licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

namespace banyandb.v1;

// BinaryOp specify the operation imposed to the given query condition
enum BinaryOp: byte {
    EQ,
    NE,
    LT,
    GT,
    LE,
    GE,
    HAVING,
    NOT_HAVING,
    RANGE
}

// ByteValue is the byte-representation of the value of a Tag
table ByteValue {
    value: [ubyte];
}

// Tag is the building block of a record which is equivalent to a key-value pair.
// In the context of Trace, it could be metadata of a trace such as service_name, serivce_instance, etc.
// Besides, other fields/tags are organized in key-value pair in the underlying storage layer.
// One should notice that the values can be a multi-value.
table Tag {
    key: [ubyte];
    values: [ByteValue];
}

// TagQuery consists of the query condition with a binary operator to be imposed
table TagQuery {
    op: BinaryOp;
    condition: Tag;
}

// Sort is either descending or ascending
enum Sort : byte {
    DESC,
    ASC
}

// QueryOrder means a Sort operation to be done for a given field.
// The field can be only the type of Integer.
table QueryOrder {
    field_name: string;
    sort: Sort;
}

// Entity represents a Span defined in Google Dapper paper.
// Or equivalently a Segment in Skywalking.
table Entity {
    // entity_id could be span_id of a Span or segment_id of a Segment
    entity_id: string;
    trace_id: string;
    start_time: uint64;
    end_time: uint64;
    duration: uint64;
    data_binary: [ubyte];
    // fields contains all indexed Field
    fields: [Tag];
    // tags contains all non-indexed Field
    tags: [Tag];
}

// TracesResponse is the response for a query to the Query module. 
table TracesResponse {
    // entities are the actual data returned
    entities: [Entity];
    // count means
    // 1) total number of entities found if the corresponding request is a parametrized search regardless of the limit parameter
    // 2) otherwise, length of the `entities` if it is a primary-key fetch (i.e trace_id)
    count: uint64;
}

// TraceQueryCriteria is the request contract for query.
table TraceQueryCriteria {
    trace_id: string;
    // 1) the start_time_nanoseconds and end_time_nanoseconds are optional if only trace_id is given,
    // 2) while these two conditions are required if a complex search condition is given
    start_time_nanoseconds: uint64;
    end_time_nanoseconds: uint64;
    // limit is used to impose a boundary on the number of records being returned
    limit: uint32;
    // order_by is given to specify the sort for a field. So far, only fields in the type of Integer are supported
    order_by: QueryOrder;
    // fields are indexed
    fields: [TagQuery];
    // tag are not indexed
    tags: [TagQuery];
}

// Query is the RPC service exposed
rpc_service Query {
    QueryTraces(TraceQueryCriteria):TracesResponse;
}
