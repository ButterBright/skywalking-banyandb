// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package v1

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type ValueType byte

const (
	ValueTypeNONE        ValueType = 0
	ValueTypeString      ValueType = 1
	ValueTypeBoolean     ValueType = 2
	ValueTypeArrayString ValueType = 3
	ValueTypeUint        ValueType = 4
	ValueTypeArrayByte   ValueType = 5
	ValueTypeTags        ValueType = 6
)

var EnumNamesValueType = map[ValueType]string{
	ValueTypeNONE:        "NONE",
	ValueTypeString:      "String",
	ValueTypeBoolean:     "Boolean",
	ValueTypeArrayString: "ArrayString",
	ValueTypeUint:        "Uint",
	ValueTypeArrayByte:   "ArrayByte",
	ValueTypeTags:        "Tags",
}

var EnumValuesValueType = map[string]ValueType{
	"NONE":        ValueTypeNONE,
	"String":      ValueTypeString,
	"Boolean":     ValueTypeBoolean,
	"ArrayString": ValueTypeArrayString,
	"Uint":        ValueTypeUint,
	"ArrayByte":   ValueTypeArrayByte,
	"Tags":        ValueTypeTags,
}

func (v ValueType) String() string {
	if s, ok := EnumNamesValueType[v]; ok {
		return s
	}
	return "ValueType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type String struct {
	_tab flatbuffers.Table
}

func GetRootAsString(buf []byte, offset flatbuffers.UOffsetT) *String {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &String{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsString(buf []byte, offset flatbuffers.UOffsetT) *String {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &String{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *String) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *String) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *String) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func StringStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func StringAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func StringEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Boolean struct {
	_tab flatbuffers.Table
}

func GetRootAsBoolean(buf []byte, offset flatbuffers.UOffsetT) *Boolean {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Boolean{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBoolean(buf []byte, offset flatbuffers.UOffsetT) *Boolean {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Boolean{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Boolean) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Boolean) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Boolean) Value() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *Boolean) MutateValue(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func BooleanStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func BooleanAddValue(builder *flatbuffers.Builder, value bool) {
	builder.PrependBoolSlot(0, value, false)
}
func BooleanEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ArrayString struct {
	_tab flatbuffers.Table
}

func GetRootAsArrayString(buf []byte, offset flatbuffers.UOffsetT) *ArrayString {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ArrayString{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsArrayString(buf []byte, offset flatbuffers.UOffsetT) *ArrayString {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ArrayString{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ArrayString) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayString) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ArrayString) Value(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ArrayString) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ArrayStringStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ArrayStringAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func ArrayStringStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ArrayStringEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ArrayByte struct {
	_tab flatbuffers.Table
}

func GetRootAsArrayByte(buf []byte, offset flatbuffers.UOffsetT) *ArrayByte {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ArrayByte{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsArrayByte(buf []byte, offset flatbuffers.UOffsetT) *ArrayByte {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ArrayByte{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ArrayByte) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayByte) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ArrayByte) Value(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ArrayByte) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ArrayByte) MutateValue(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func ArrayByteStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ArrayByteAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func ArrayByteStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ArrayByteEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Uint struct {
	_tab flatbuffers.Table
}

func GetRootAsUint(buf []byte, offset flatbuffers.UOffsetT) *Uint {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Uint{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsUint(buf []byte, offset flatbuffers.UOffsetT) *Uint {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Uint{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Uint) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Uint) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Uint) Value() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Uint) MutateValue(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

func UintStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func UintAddValue(builder *flatbuffers.Builder, value uint32) {
	builder.PrependUint32Slot(0, value, 0)
}
func UintEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Tags struct {
	_tab flatbuffers.Table
}

func GetRootAsTags(buf []byte, offset flatbuffers.UOffsetT) *Tags {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Tags{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTags(buf []byte, offset flatbuffers.UOffsetT) *Tags {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Tags{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Tags) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Tags) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Tags) Value(obj *Tag, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Tags) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TagsStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func TagsAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func TagsStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TagsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Tag struct {
	_tab flatbuffers.Table
}

func GetRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Tag{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Tag{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Tag) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Tag) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Tag) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Tag) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func TagStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TagAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func TagAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func TagEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type TraceValue struct {
	_tab flatbuffers.Table
}

func GetRootAsTraceValue(buf []byte, offset flatbuffers.UOffsetT) *TraceValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TraceValue{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTraceValue(buf []byte, offset flatbuffers.UOffsetT) *TraceValue {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TraceValue{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TraceValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TraceValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TraceValue) ValueType() ValueType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ValueType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TraceValue) MutateValueType(n ValueType) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *TraceValue) Value(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func TraceValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TraceValueAddValueType(builder *flatbuffers.Builder, valueType ValueType) {
	builder.PrependByteSlot(0, byte(valueType), 0)
}
func TraceValueAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func TraceValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type WriteTracesEntity struct {
	_tab flatbuffers.Table
}

func GetRootAsWriteTracesEntity(buf []byte, offset flatbuffers.UOffsetT) *WriteTracesEntity {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WriteTracesEntity{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsWriteTracesEntity(buf []byte, offset flatbuffers.UOffsetT) *WriteTracesEntity {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WriteTracesEntity{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *WriteTracesEntity) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WriteTracesEntity) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WriteTracesEntity) Keys(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *WriteTracesEntity) KeysLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WriteTracesEntity) Values(obj *TraceValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *WriteTracesEntity) ValuesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func WriteTracesEntityStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func WriteTracesEntityAddKeys(builder *flatbuffers.Builder, keys flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(keys), 0)
}
func WriteTracesEntityStartKeysVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WriteTracesEntityAddValues(builder *flatbuffers.Builder, values flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(values), 0)
}
func WriteTracesEntityStartValuesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WriteTracesEntityEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type WriteTracesResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsWriteTracesResponse(buf []byte, offset flatbuffers.UOffsetT) *WriteTracesResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WriteTracesResponse{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsWriteTracesResponse(buf []byte, offset flatbuffers.UOffsetT) *WriteTracesResponse {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WriteTracesResponse{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *WriteTracesResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WriteTracesResponse) Table() flatbuffers.Table {
	return rcv._tab
}

func WriteTracesResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func WriteTracesResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
