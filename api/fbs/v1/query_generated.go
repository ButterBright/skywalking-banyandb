// Licensed to Apache Software Foundation (ASF) under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Apache Software Foundation (ASF) licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package v1

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type BinaryOp int8

const (
	BinaryOpEQ         BinaryOp = 0
	BinaryOpNE         BinaryOp = 1
	BinaryOpLT         BinaryOp = 2
	BinaryOpGT         BinaryOp = 3
	BinaryOpLE         BinaryOp = 4
	BinaryOpGE         BinaryOp = 5
	BinaryOpHAVING     BinaryOp = 6
	BinaryOpNOT_HAVING BinaryOp = 7
	BinaryOpRANGE      BinaryOp = 8
)

var EnumNamesBinaryOp = map[BinaryOp]string{
	BinaryOpEQ:         "EQ",
	BinaryOpNE:         "NE",
	BinaryOpLT:         "LT",
	BinaryOpGT:         "GT",
	BinaryOpLE:         "LE",
	BinaryOpGE:         "GE",
	BinaryOpHAVING:     "HAVING",
	BinaryOpNOT_HAVING: "NOT_HAVING",
	BinaryOpRANGE:      "RANGE",
}

var EnumValuesBinaryOp = map[string]BinaryOp{
	"EQ":         BinaryOpEQ,
	"NE":         BinaryOpNE,
	"LT":         BinaryOpLT,
	"GT":         BinaryOpGT,
	"LE":         BinaryOpLE,
	"GE":         BinaryOpGE,
	"HAVING":     BinaryOpHAVING,
	"NOT_HAVING": BinaryOpNOT_HAVING,
	"RANGE":      BinaryOpRANGE,
}

func (v BinaryOp) String() string {
	if s, ok := EnumNamesBinaryOp[v]; ok {
		return s
	}
	return "BinaryOp(" + strconv.FormatInt(int64(v), 10) + ")"
}

type TraceState int8

const (
	TraceStateALL     TraceState = 0
	TraceStateSUCCESS TraceState = 1
	TraceStateERROR   TraceState = 2
)

var EnumNamesTraceState = map[TraceState]string{
	TraceStateALL:     "ALL",
	TraceStateSUCCESS: "SUCCESS",
	TraceStateERROR:   "ERROR",
}

var EnumValuesTraceState = map[string]TraceState{
	"ALL":     TraceStateALL,
	"SUCCESS": TraceStateSUCCESS,
	"ERROR":   TraceStateERROR,
}

func (v TraceState) String() string {
	if s, ok := EnumNamesTraceState[v]; ok {
		return s
	}
	return "TraceState(" + strconv.FormatInt(int64(v), 10) + ")"
}

type QueryOrder int8

const (
	QueryOrderByStartTime QueryOrder = 0
	QueryOrderByDuration  QueryOrder = 1
)

var EnumNamesQueryOrder = map[QueryOrder]string{
	QueryOrderByStartTime: "ByStartTime",
	QueryOrderByDuration:  "ByDuration",
}

var EnumValuesQueryOrder = map[string]QueryOrder{
	"ByStartTime": QueryOrderByStartTime,
	"ByDuration":  QueryOrderByDuration,
}

func (v QueryOrder) String() string {
	if s, ok := EnumNamesQueryOrder[v]; ok {
		return s
	}
	return "QueryOrder(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Sort int8

const (
	SortDESC Sort = 0
	SortASC  Sort = 1
)

var EnumNamesSort = map[Sort]string{
	SortDESC: "DESC",
	SortASC:  "ASC",
}

var EnumValuesSort = map[string]Sort{
	"DESC": SortDESC,
	"ASC":  SortASC,
}

func (v Sort) String() string {
	if s, ok := EnumNamesSort[v]; ok {
		return s
	}
	return "Sort(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ByteValue struct {
	_tab flatbuffers.Table
}

func GetRootAsByteValue(buf []byte, offset flatbuffers.UOffsetT) *ByteValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ByteValue{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsByteValue(buf []byte, offset flatbuffers.UOffsetT) *ByteValue {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ByteValue{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ByteValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ByteValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ByteValue) Value(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ByteValue) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ByteValue) ValueBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ByteValue) MutateValue(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func ByteValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ByteValueAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func ByteValueStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ByteValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Tag struct {
	_tab flatbuffers.Table
}

func GetRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Tag{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Tag{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Tag) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Tag) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Tag) Key(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Tag) KeyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Tag) KeyBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Tag) MutateKey(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Tag) Values(obj *ByteValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Tag) ValuesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TagStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TagAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func TagStartKeyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func TagAddValues(builder *flatbuffers.Builder, values flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(values), 0)
}
func TagStartValuesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TagEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type TagQuery struct {
	_tab flatbuffers.Table
}

func GetRootAsTagQuery(buf []byte, offset flatbuffers.UOffsetT) *TagQuery {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TagQuery{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTagQuery(buf []byte, offset flatbuffers.UOffsetT) *TagQuery {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TagQuery{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TagQuery) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TagQuery) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TagQuery) Tag(obj *Tag) *Tag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Tag)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TagQuery) Op() BinaryOp {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return BinaryOp(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TagQuery) MutateOp(n BinaryOp) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func TagQueryStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TagQueryAddTag(builder *flatbuffers.Builder, tag flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(tag), 0)
}
func TagQueryAddOp(builder *flatbuffers.Builder, op BinaryOp) {
	builder.PrependInt8Slot(1, int8(op), 0)
}
func TagQueryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Entity struct {
	_tab flatbuffers.Table
}

func GetRootAsEntity(buf []byte, offset flatbuffers.UOffsetT) *Entity {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Entity{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsEntity(buf []byte, offset flatbuffers.UOffsetT) *Entity {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Entity{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Entity) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Entity) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Entity) EntityId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) Statement() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) ServiceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) ServiceInstanceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) EndpointName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) EndpointId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) StartTime() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateStartTime(n uint64) bool {
	return rcv._tab.MutateUint64Slot(18, n)
}

func (rcv *Entity) EndTime() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateEndTime(n uint64) bool {
	return rcv._tab.MutateUint64Slot(20, n)
}

func (rcv *Entity) Duration() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateDuration(n uint64) bool {
	return rcv._tab.MutateUint64Slot(22, n)
}

func (rcv *Entity) TraceState() TraceState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return TraceState(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Entity) MutateTraceState(n TraceState) bool {
	return rcv._tab.MutateInt8Slot(24, int8(n))
}

func (rcv *Entity) DataBinary(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Entity) DataBinaryLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Entity) DataBinaryBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) MutateDataBinary(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Entity) Tags(obj *Tag, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Entity) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func EntityStart(builder *flatbuffers.Builder) {
	builder.StartObject(13)
}
func EntityAddEntityId(builder *flatbuffers.Builder, entityId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(entityId), 0)
}
func EntityAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(traceId), 0)
}
func EntityAddStatement(builder *flatbuffers.Builder, statement flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(statement), 0)
}
func EntityAddServiceId(builder *flatbuffers.Builder, serviceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(serviceId), 0)
}
func EntityAddServiceInstanceId(builder *flatbuffers.Builder, serviceInstanceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(serviceInstanceId), 0)
}
func EntityAddEndpointName(builder *flatbuffers.Builder, endpointName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(endpointName), 0)
}
func EntityAddEndpointId(builder *flatbuffers.Builder, endpointId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(endpointId), 0)
}
func EntityAddStartTime(builder *flatbuffers.Builder, startTime uint64) {
	builder.PrependUint64Slot(7, startTime, 0)
}
func EntityAddEndTime(builder *flatbuffers.Builder, endTime uint64) {
	builder.PrependUint64Slot(8, endTime, 0)
}
func EntityAddDuration(builder *flatbuffers.Builder, duration uint64) {
	builder.PrependUint64Slot(9, duration, 0)
}
func EntityAddTraceState(builder *flatbuffers.Builder, traceState TraceState) {
	builder.PrependInt8Slot(10, int8(traceState), 0)
}
func EntityAddDataBinary(builder *flatbuffers.Builder, dataBinary flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(dataBinary), 0)
}
func EntityStartDataBinaryVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func EntityAddTags(builder *flatbuffers.Builder, tags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(tags), 0)
}
func EntityStartTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EntityEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type BasicTrace struct {
	_tab flatbuffers.Table
}

func GetRootAsBasicTrace(buf []byte, offset flatbuffers.UOffsetT) *BasicTrace {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BasicTrace{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBasicTrace(buf []byte, offset flatbuffers.UOffsetT) *BasicTrace {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BasicTrace{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BasicTrace) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BasicTrace) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *BasicTrace) EntityId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *BasicTrace) EndpointNames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *BasicTrace) EndpointNamesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *BasicTrace) Duration() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *BasicTrace) MutateDuration(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *BasicTrace) StartTime() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *BasicTrace) MutateStartTime(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *BasicTrace) TraceState() TraceState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return TraceState(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *BasicTrace) MutateTraceState(n TraceState) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

func (rcv *BasicTrace) TraceIds(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *BasicTrace) TraceIdsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func BasicTraceStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func BasicTraceAddEntityId(builder *flatbuffers.Builder, entityId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(entityId), 0)
}
func BasicTraceAddEndpointNames(builder *flatbuffers.Builder, endpointNames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(endpointNames), 0)
}
func BasicTraceStartEndpointNamesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BasicTraceAddDuration(builder *flatbuffers.Builder, duration uint64) {
	builder.PrependUint64Slot(2, duration, 0)
}
func BasicTraceAddStartTime(builder *flatbuffers.Builder, startTime uint64) {
	builder.PrependUint64Slot(3, startTime, 0)
}
func BasicTraceAddTraceState(builder *flatbuffers.Builder, traceState TraceState) {
	builder.PrependInt8Slot(4, int8(traceState), 0)
}
func BasicTraceAddTraceIds(builder *flatbuffers.Builder, traceIds flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(traceIds), 0)
}
func BasicTraceStartTraceIdsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BasicTraceEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type TraceBrief struct {
	_tab flatbuffers.Table
}

func GetRootAsTraceBrief(buf []byte, offset flatbuffers.UOffsetT) *TraceBrief {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TraceBrief{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTraceBrief(buf []byte, offset flatbuffers.UOffsetT) *TraceBrief {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TraceBrief{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TraceBrief) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TraceBrief) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TraceBrief) Traces(obj *BasicTrace, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TraceBrief) TracesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *TraceBrief) Total() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceBrief) MutateTotal(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func TraceBriefStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TraceBriefAddTraces(builder *flatbuffers.Builder, traces flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(traces), 0)
}
func TraceBriefStartTracesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceBriefAddTotal(builder *flatbuffers.Builder, total int32) {
	builder.PrependInt32Slot(1, total, 0)
}
func TraceBriefEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type TraceQueryCriteria struct {
	_tab flatbuffers.Table
}

func GetRootAsTraceQueryCriteria(buf []byte, offset flatbuffers.UOffsetT) *TraceQueryCriteria {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TraceQueryCriteria{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTraceQueryCriteria(buf []byte, offset flatbuffers.UOffsetT) *TraceQueryCriteria {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TraceQueryCriteria{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TraceQueryCriteria) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TraceQueryCriteria) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TraceQueryCriteria) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) StartTimeNanoseconds() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateStartTimeNanoseconds(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *TraceQueryCriteria) EndTimeNanoseconds() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateEndTimeNanoseconds(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *TraceQueryCriteria) MinDuration() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateMinDuration(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *TraceQueryCriteria) MaxDuration() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateMaxDuration(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func (rcv *TraceQueryCriteria) EndpointName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) EndpointId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) ServiceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) ServiceInstanceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) Limit() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateLimit(n uint32) bool {
	return rcv._tab.MutateUint32Slot(22, n)
}

func (rcv *TraceQueryCriteria) QueryOrder() QueryOrder {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return QueryOrder(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateQueryOrder(n QueryOrder) bool {
	return rcv._tab.MutateInt8Slot(24, int8(n))
}

func (rcv *TraceQueryCriteria) Sort() Sort {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return Sort(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateSort(n Sort) bool {
	return rcv._tab.MutateInt8Slot(26, int8(n))
}

func (rcv *TraceQueryCriteria) TraceState() TraceState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return TraceState(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateTraceState(n TraceState) bool {
	return rcv._tab.MutateInt8Slot(28, int8(n))
}

func (rcv *TraceQueryCriteria) Tags(obj *TagQuery, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TraceQueryCriteria) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *TraceQueryCriteria) Fields(obj *TagQuery, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TraceQueryCriteria) FieldsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TraceQueryCriteriaStart(builder *flatbuffers.Builder) {
	builder.StartObject(15)
}
func TraceQueryCriteriaAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(traceId), 0)
}
func TraceQueryCriteriaAddStartTimeNanoseconds(builder *flatbuffers.Builder, startTimeNanoseconds uint64) {
	builder.PrependUint64Slot(1, startTimeNanoseconds, 0)
}
func TraceQueryCriteriaAddEndTimeNanoseconds(builder *flatbuffers.Builder, endTimeNanoseconds uint64) {
	builder.PrependUint64Slot(2, endTimeNanoseconds, 0)
}
func TraceQueryCriteriaAddMinDuration(builder *flatbuffers.Builder, minDuration uint64) {
	builder.PrependUint64Slot(3, minDuration, 0)
}
func TraceQueryCriteriaAddMaxDuration(builder *flatbuffers.Builder, maxDuration uint64) {
	builder.PrependUint64Slot(4, maxDuration, 0)
}
func TraceQueryCriteriaAddEndpointName(builder *flatbuffers.Builder, endpointName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(endpointName), 0)
}
func TraceQueryCriteriaAddEndpointId(builder *flatbuffers.Builder, endpointId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(endpointId), 0)
}
func TraceQueryCriteriaAddServiceId(builder *flatbuffers.Builder, serviceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(serviceId), 0)
}
func TraceQueryCriteriaAddServiceInstanceId(builder *flatbuffers.Builder, serviceInstanceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(serviceInstanceId), 0)
}
func TraceQueryCriteriaAddLimit(builder *flatbuffers.Builder, limit uint32) {
	builder.PrependUint32Slot(9, limit, 0)
}
func TraceQueryCriteriaAddQueryOrder(builder *flatbuffers.Builder, queryOrder QueryOrder) {
	builder.PrependInt8Slot(10, int8(queryOrder), 0)
}
func TraceQueryCriteriaAddSort(builder *flatbuffers.Builder, sort Sort) {
	builder.PrependInt8Slot(11, int8(sort), 0)
}
func TraceQueryCriteriaAddTraceState(builder *flatbuffers.Builder, traceState TraceState) {
	builder.PrependInt8Slot(12, int8(traceState), 0)
}
func TraceQueryCriteriaAddTags(builder *flatbuffers.Builder, tags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(tags), 0)
}
func TraceQueryCriteriaStartTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceQueryCriteriaAddFields(builder *flatbuffers.Builder, fields flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(fields), 0)
}
func TraceQueryCriteriaStartFieldsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceQueryCriteriaEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Trace struct {
	_tab flatbuffers.Table
}

func GetRootAsTrace(buf []byte, offset flatbuffers.UOffsetT) *Trace {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Trace{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTrace(buf []byte, offset flatbuffers.UOffsetT) *Trace {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Trace{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Trace) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Trace) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Trace) Entities(obj *Entity, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Trace) EntitiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TraceStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func TraceAddEntities(builder *flatbuffers.Builder, entities flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(entities), 0)
}
func TraceStartEntitiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type GetTraceRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsGetTraceRequest(buf []byte, offset flatbuffers.UOffsetT) *GetTraceRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GetTraceRequest{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsGetTraceRequest(buf []byte, offset flatbuffers.UOffsetT) *GetTraceRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GetTraceRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *GetTraceRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GetTraceRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GetTraceRequest) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func GetTraceRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func GetTraceRequestAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(traceId), 0)
}
func GetTraceRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
