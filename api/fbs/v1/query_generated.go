//
// Licensed to Apache Software Foundation (ASF) under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Apache Software Foundation (ASF) licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package v1

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type BinaryOp int8

const (
	BinaryOpEQ         BinaryOp = 0
	BinaryOpNE         BinaryOp = 1
	BinaryOpLT         BinaryOp = 2
	BinaryOpGT         BinaryOp = 3
	BinaryOpLE         BinaryOp = 4
	BinaryOpGE         BinaryOp = 5
	BinaryOpHAVING     BinaryOp = 6
	BinaryOpNOT_HAVING BinaryOp = 7
	BinaryOpRANGE      BinaryOp = 8
)

var EnumNamesBinaryOp = map[BinaryOp]string{
	BinaryOpEQ:         "EQ",
	BinaryOpNE:         "NE",
	BinaryOpLT:         "LT",
	BinaryOpGT:         "GT",
	BinaryOpLE:         "LE",
	BinaryOpGE:         "GE",
	BinaryOpHAVING:     "HAVING",
	BinaryOpNOT_HAVING: "NOT_HAVING",
	BinaryOpRANGE:      "RANGE",
}

var EnumValuesBinaryOp = map[string]BinaryOp{
	"EQ":         BinaryOpEQ,
	"NE":         BinaryOpNE,
	"LT":         BinaryOpLT,
	"GT":         BinaryOpGT,
	"LE":         BinaryOpLE,
	"GE":         BinaryOpGE,
	"HAVING":     BinaryOpHAVING,
	"NOT_HAVING": BinaryOpNOT_HAVING,
	"RANGE":      BinaryOpRANGE,
}

func (v BinaryOp) String() string {
	if s, ok := EnumNamesBinaryOp[v]; ok {
		return s
	}
	return "BinaryOp(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Sort int8

const (
	SortDESC Sort = 0
	SortASC  Sort = 1
)

var EnumNamesSort = map[Sort]string{
	SortDESC: "DESC",
	SortASC:  "ASC",
}

var EnumValuesSort = map[string]Sort{
	"DESC": SortDESC,
	"ASC":  SortASC,
}

func (v Sort) String() string {
	if s, ok := EnumNamesSort[v]; ok {
		return s
	}
	return "Sort(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ByteValue struct {
	_tab flatbuffers.Table
}

func GetRootAsByteValue(buf []byte, offset flatbuffers.UOffsetT) *ByteValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ByteValue{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsByteValue(buf []byte, offset flatbuffers.UOffsetT) *ByteValue {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ByteValue{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ByteValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ByteValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ByteValue) Value(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ByteValue) ValueLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ByteValue) ValueBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ByteValue) MutateValue(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func ByteValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ByteValueAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(value), 0)
}
func ByteValueStartValueVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ByteValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Tag struct {
	_tab flatbuffers.Table
}

func GetRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Tag{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTag(buf []byte, offset flatbuffers.UOffsetT) *Tag {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Tag{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Tag) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Tag) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Tag) Key(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Tag) KeyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Tag) KeyBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Tag) MutateKey(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Tag) Values(obj *ByteValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Tag) ValuesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TagStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TagAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func TagStartKeyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func TagAddValues(builder *flatbuffers.Builder, values flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(values), 0)
}
func TagStartValuesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TagEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TagQuery struct {
	_tab flatbuffers.Table
}

func GetRootAsTagQuery(buf []byte, offset flatbuffers.UOffsetT) *TagQuery {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TagQuery{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTagQuery(buf []byte, offset flatbuffers.UOffsetT) *TagQuery {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TagQuery{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TagQuery) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TagQuery) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TagQuery) Op() BinaryOp {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return BinaryOp(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *TagQuery) MutateOp(n BinaryOp) bool {
	return rcv._tab.MutateInt8Slot(4, int8(n))
}

func (rcv *TagQuery) Condition(obj *Tag) *Tag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Tag)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func TagQueryStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TagQueryAddOp(builder *flatbuffers.Builder, op BinaryOp) {
	builder.PrependInt8Slot(0, int8(op), 0)
}
func TagQueryAddCondition(builder *flatbuffers.Builder, condition flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(condition), 0)
}
func TagQueryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type QueryOrder struct {
	_tab flatbuffers.Table
}

func GetRootAsQueryOrder(buf []byte, offset flatbuffers.UOffsetT) *QueryOrder {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &QueryOrder{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsQueryOrder(buf []byte, offset flatbuffers.UOffsetT) *QueryOrder {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &QueryOrder{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *QueryOrder) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *QueryOrder) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *QueryOrder) FieldName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *QueryOrder) Sort() Sort {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Sort(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *QueryOrder) MutateSort(n Sort) bool {
	return rcv._tab.MutateInt8Slot(6, int8(n))
}

func QueryOrderStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func QueryOrderAddFieldName(builder *flatbuffers.Builder, fieldName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(fieldName), 0)
}
func QueryOrderAddSort(builder *flatbuffers.Builder, sort Sort) {
	builder.PrependInt8Slot(1, int8(sort), 0)
}
func QueryOrderEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Entity struct {
	_tab flatbuffers.Table
}

func GetRootAsEntity(buf []byte, offset flatbuffers.UOffsetT) *Entity {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Entity{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsEntity(buf []byte, offset flatbuffers.UOffsetT) *Entity {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Entity{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Entity) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Entity) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Entity) EntityId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) StartTime() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateStartTime(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *Entity) EndTime() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateEndTime(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *Entity) Duration() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Entity) MutateDuration(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func (rcv *Entity) DataBinary(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Entity) DataBinaryLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Entity) DataBinaryBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Entity) MutateDataBinary(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Entity) Fields(obj *Tag, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Entity) FieldsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Entity) Tags(obj *Tag, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Entity) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func EntityStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func EntityAddEntityId(builder *flatbuffers.Builder, entityId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(entityId), 0)
}
func EntityAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(traceId), 0)
}
func EntityAddStartTime(builder *flatbuffers.Builder, startTime uint64) {
	builder.PrependUint64Slot(2, startTime, 0)
}
func EntityAddEndTime(builder *flatbuffers.Builder, endTime uint64) {
	builder.PrependUint64Slot(3, endTime, 0)
}
func EntityAddDuration(builder *flatbuffers.Builder, duration uint64) {
	builder.PrependUint64Slot(4, duration, 0)
}
func EntityAddDataBinary(builder *flatbuffers.Builder, dataBinary flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(dataBinary), 0)
}
func EntityStartDataBinaryVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func EntityAddFields(builder *flatbuffers.Builder, fields flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(fields), 0)
}
func EntityStartFieldsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EntityAddTags(builder *flatbuffers.Builder, tags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(tags), 0)
}
func EntityStartTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EntityEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TracesResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsTracesResponse(buf []byte, offset flatbuffers.UOffsetT) *TracesResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TracesResponse{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTracesResponse(buf []byte, offset flatbuffers.UOffsetT) *TracesResponse {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TracesResponse{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TracesResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TracesResponse) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TracesResponse) Entities(obj *Entity, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TracesResponse) EntitiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *TracesResponse) Count() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TracesResponse) MutateCount(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func TracesResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TracesResponseAddEntities(builder *flatbuffers.Builder, entities flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(entities), 0)
}
func TracesResponseStartEntitiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TracesResponseAddCount(builder *flatbuffers.Builder, count uint64) {
	builder.PrependUint64Slot(1, count, 0)
}
func TracesResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TraceQueryCriteria struct {
	_tab flatbuffers.Table
}

func GetRootAsTraceQueryCriteria(buf []byte, offset flatbuffers.UOffsetT) *TraceQueryCriteria {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TraceQueryCriteria{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsTraceQueryCriteria(buf []byte, offset flatbuffers.UOffsetT) *TraceQueryCriteria {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &TraceQueryCriteria{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *TraceQueryCriteria) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TraceQueryCriteria) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TraceQueryCriteria) TraceId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TraceQueryCriteria) StartTimeNanoseconds() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateStartTimeNanoseconds(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *TraceQueryCriteria) EndTimeNanoseconds() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateEndTimeNanoseconds(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *TraceQueryCriteria) Limit() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TraceQueryCriteria) MutateLimit(n uint32) bool {
	return rcv._tab.MutateUint32Slot(10, n)
}

func (rcv *TraceQueryCriteria) OrderBy(obj *QueryOrder) *QueryOrder {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(QueryOrder)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TraceQueryCriteria) Tags(obj *TagQuery, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TraceQueryCriteria) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *TraceQueryCriteria) Fields(obj *TagQuery, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TraceQueryCriteria) FieldsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TraceQueryCriteriaStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func TraceQueryCriteriaAddTraceId(builder *flatbuffers.Builder, traceId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(traceId), 0)
}
func TraceQueryCriteriaAddStartTimeNanoseconds(builder *flatbuffers.Builder, startTimeNanoseconds uint64) {
	builder.PrependUint64Slot(1, startTimeNanoseconds, 0)
}
func TraceQueryCriteriaAddEndTimeNanoseconds(builder *flatbuffers.Builder, endTimeNanoseconds uint64) {
	builder.PrependUint64Slot(2, endTimeNanoseconds, 0)
}
func TraceQueryCriteriaAddLimit(builder *flatbuffers.Builder, limit uint32) {
	builder.PrependUint32Slot(3, limit, 0)
}
func TraceQueryCriteriaAddOrderBy(builder *flatbuffers.Builder, orderBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(orderBy), 0)
}
func TraceQueryCriteriaAddTags(builder *flatbuffers.Builder, tags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(tags), 0)
}
func TraceQueryCriteriaStartTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceQueryCriteriaAddFields(builder *flatbuffers.Builder, fields flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(fields), 0)
}
func TraceQueryCriteriaStartFieldsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TraceQueryCriteriaEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
